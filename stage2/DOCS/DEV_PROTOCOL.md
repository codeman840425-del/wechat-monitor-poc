# 开发协作协议手册

**版本**: v1.0  
**创建时间**: 2026-02-03  
**适用范围**: wechat-monitor-poc 项目所有开发任务

---

## 体系架构（三文件联动）

```
ITERATIVE_BOARD.md (总看板)
├── 管理：需求、步骤拆分、多轮迭代历史、整体进度
├── 更新时机：需求变更、步骤状态变更、每轮迭代结束
└── 作用：让你和我掌握项目全貌

ERROR_LOG.md (错误档案)  
├── 管理：开发过程中产生的所有报错、修复记录、遗留问题
├── 更新时机：开发中遇到错误立即记录、自修复后更新状态、交付前汇总
└── 作用：透明化开发过程，防止"暗箱出错"

STEP_MANUAL.md (交付手册)
├── 管理：当前步骤的测试指南、验收标准、已知问题
├── 更新时机：步骤开发完成且自修复通过后、用户反馈后更新验证项
└── 作用：告诉你如何测试，明确验收标准

DEV_PROTOCOL.md (本文件)
├── 管理：开发流程规范、错误捕获协议、自修复SOP
├── 更新时机：流程优化、规则调整
└── 作用：完整开发协作手册，规范开发行为
```

**黄金法则**: 没有更新STEP_MANUAL.md就不算完成，没有ERROR_LOG.md记录就是开发失职。

---

## 文件1：ITERATIVE_BOARD.md 规格

**路径**: `DOCS/ITERATIVE_BOARD.md`

**模板**:
```markdown
# 项目迭代看板

## 当前需求
**原始需求**: [用户原话粘贴]
**澄清后**: [AI理解的具体目标，必须用户确认]
**当前状态**: [需求分析中/开发中/测试阶段/阻塞/已完成]
**创建时间**: [日期]
**最后更新**: [日期]

## 步骤路线图（总览）
- [ ] 步骤1: [名称] | 交付: [文件列表] | 状态: [待开始/进行中/待测试/已完成]
- [ ] 步骤2: [名称] | 交付: [文件列表] | 状态: [待开始/进行中/待测试/已完成]
- [ ] 步骤3: [名称] | 交付: [文件列表] | 状态: [待开始/进行中/待测试/已完成]

**当前进行**: 步骤[X] - [简述当前动作]

## 迭代历史（问题追踪）
### Round 1 - 步骤[X]初版交付
**实施内容**: [简述改了什么]
**ERROR_LOG统计**: 发现[Y]个错误，自修复[Z]个，遗留[N]个
**用户测试反馈**: [用户描述的bug/报错]
**修复方案**: [如何修复的]
**最终状态**: [已解决/待验证]

### Round 2 - 修复迭代
...

## 阻塞点
[等待用户输入的内容，如需求澄清/环境配置/测试反馈]

## 下一步行动建议
[基于当前状态，AI建议的下一步]
```

**更新规则**:
- 每收到新需求：立即创建或重置此文件，填写"原始需求"和"步骤路线图"
- 每完成一个步骤：更新"步骤路线图"对应项为"待测试"或"已完成"
- 每轮迭代结束：追加"迭代历史"
- 每日首次对话：读取此文件，用3句话总结当前状态

---

## 文件2：ERROR_LOG.md 规格

**路径**: `DOCS/ERROR_LOG.md`

**模板**:
```markdown
# 开发期错误档案

## 当前开发轮次
**Round**: [N]  
**步骤**: [步骤X - 名称]  
**开发时间**: [开始时间] - [结束时间]

---

## 实时错误记录（开发时实时追加）

### Error #[自动编号] - [时间戳]
**代码位置**: [文件:行号]
**错误类型**: [SyntaxError/ImportError/NameError/TypeError/RuntimeError/LogicError]
**错误信息**:
```
[完整报错堆栈，必须包含最后5行]
```
**触发场景**: [AI当时在做什么，如"测试消息解析函数"]
**AI根因分析**: [为什么会错，如"忘记导入datetime模块"]
**临时处理**: [怎么绕过的，如"临时加了try-except包裹"或"注释掉该行继续开发"]
**修复状态**: [待修复/修复中/已修复/需用户介入/已放弃]

---

## 本轮错误汇总（开发结束后更新）
**总错误数**: [X]
**分类统计**:
- P0-阻断性(语法/导入/命名): [N]个
- P1-类型错误: [N]个  
- P2-运行时异常: [N]个
- P3-逻辑错误: [N]个

**待修复清单**:
1. Error #[ID] - [简述]
2. Error #[ID] - [简述]

---

## 修复记录（修复后更新）
| 错误ID | 修复方案 | 验证方式 | 结果 | 修复时间 |
|-------|---------|---------|------|---------|
| #1 | [如：添加缺失导入] | [运行导入测试] | [通过] | [时间] |
| #2 | [如：修正类型注解] | [pyright检查] | [失败，需重试] | [时间] |
```

**强制记录场景**（只要发生，必须立即记录）:
1. 任何`SyntaxError`（语法错误）
2. 任何`ImportError/ModuleNotFoundError`（导入失败）
3. 任何`NameError`（未定义变量）
4. 任何运行时异常（程序崩溃）
5. 任何类型检查错误（如果运行了类型检查）
6. 逻辑错误（结果不符合预期，即使没抛异常）

---

## 文件3：STEP_MANUAL.md 规格

**路径**: `DOCS/STEP_MANUAL.md`

**模板**:
```markdown
# 步骤交付手册

> **对应步骤**: [步骤X - 名称]
> **版本**: [commit hash或时间戳]
> **状态**: [已自修复，待测试/已修复，请重测/最终版]

---

## 1. 本次交付了什么
[用通俗语言说明实现了什么功能，修改了哪些文件，关键逻辑]

---

## 2. 测试前准备
```bash
# 必须执行的准备命令
git pull
pip install -r requirements.txt  # 如有新依赖
python health_check.py  # 基础检查
```

---

## 3. 功能测试指南（按顺序执行）

### 测试A：基础功能（必做）
**目的**: 确认代码能跑，不报错
**命令**:
```bash
[具体可复制的命令]
```
**预期结果**: [描述应该看到什么]
**通过标准**: [复选框，如"控制台无报错"]

### 测试B：核心功能（必做）
**目的**: 验证本次步骤的核心功能
**操作步骤**:
1. [如：在微信发送"测试"]
2. [如：等待5秒]
3. [如：查看数据库]

**验证命令**:
```bash
[查询或验证命令]
```

**预期结果**:
- [ ] [检查点1]
- [ ] [检查点2]

### 测试C：边界情况（如有）
[异常输入、极端情况等]

---

## 4. 已知问题（来自ERROR_LOG）
**已自动修复**（无需关注）:
- [X]个错误已处理，包括[简述]

**待观察**（测试时请留意）:
1. [Error #3]: 在[场景]可能出现[现象]，如遇到请记录

**需用户介入**（无法自动修复）:
1. [Error #5]: 需要[资源/环境]，暂无法模拟

---

## 5. 反馈收集（你填写）

**测试结果**: [全部通过/部分失败/完全失败]

**失败详情**（如有）:
```
粘贴报错或描述现象
```

**你的判断**:
- [ ] 通过，进入下一步
- [ ] 不通过，需要修复（见Round [N+1]）
- [ ] 需求变更，调整方向

---

## 6. 回滚指南（如需要）
```bash
git checkout [文件]  # 回滚特定文件
# 或
git reset --hard HEAD~1  # 回滚到交付前
```
```

---

## 开发期错误捕获协议

### 开发时自检清单（每个函数/文件后执行）

**保存文件前必须自问**:
```markdown
**文件**: [路径]
**自检时间**: [时间]
- [ ] 导入测试：`python -c "import [模块]"` 无报错
- [ ] 语法检查：`python -m py_compile [文件]` 无报错  
- [ ] 类型检查：`pyright [文件]`（如有配置）
- [ ] 运行时测试：核心函数可调用不抛异常

**发现的错误**: [列表或"无"]
**已记录ERROR_LOG**: [是/否，记录编号]
```

### 错误捕获包装器（开发时代码规范）

在开发过程中，**任何测试代码**必须使用以下包装：

```python
import traceback
from datetime import datetime

def dev_test(test_name, func, *args, **kwargs):
    """开发期测试包装器，自动记录错误"""
    try:
        result = func(*args, **kwargs)
        print(f"✅ {test_name} 通过")
        return result
    except Exception as e:
        # 构造错误信息
        error_info = {
            "timestamp": datetime.now().isoformat(),
            "test_name": test_name,
            "error_type": type(e).__name__,
            "error_msg": str(e),
            "traceback": traceback.format_exc()[-500:],  # 最后500字符
            "file": getattr(func, '__code__', None) and func.__code__.co_filename or "unknown",
            "line": getattr(func, '__code__', None) and func.__code__.co_firstlineno or 0,
            "args": str(args)[:100]
        }
        
        # 立即记录到ERROR_LOG.md（模拟追加）
        print(f"\n❌ {test_name} 失败")
        print(f"错误类型: {error_info['error_type']}")
        print(f"错误信息: {error_info['error_msg']}")
        print(f"位置: {error_info['file']}:{error_info['line']}")
        print("⚠️  必须立即记录到 ERROR_LOG.md\n")
        
        # 返回None表示失败，但不阻断开发流程
        return None
```

**使用示例**:
```python
# 错误的方式（不允许）
result = parse_message(data)  # 如果出错，AI不知道

# 正确的方式（必须）
result = dev_test("消息解析测试", parse_message, data)
if result is None:
    # 记录错误后继续，或标记为阻塞
    pass
```

---

## 自修复流程SOP

### 触发时机
每完成一个步骤的编码，**在写STEP_MANUAL.md之前**，必须执行自修复。

### Phase 1: 错误分析（5分钟）
1. 读取ERROR_LOG.md中的所有"待修复"错误
2. 分类定级：
   - **P0-阻断性**：SyntaxError, ImportError, NameError → 必须立即修复
   - **P1-类型错误**：TypeError, AttributeError → 高优先级修复
   - **P2-运行时**：ValueError, KeyError, IndexError → 中优先级，加防御代码
   - **P3-逻辑**：结果不符 → 分析原因，标记为"需用户确认"

### Phase 2: 自动修复（按优先级）
对每个P0/P1错误：
1. **诊断**：根据traceback定位问题行
2. **修复**：
   - ImportError → 添加导入或安装依赖
   - SyntaxError → 修正语法
   - TypeError → 添加类型检查或转换
   - AttributeError → 检查对象初始化
3. **验证**：用`dev_test`重新运行相同的测试用例
4. **记录**：更新ERROR_LOG.md中该错误的状态为"已修复"或"修复失败"

**修复失败处理**：
- 如果3次尝试仍失败，标记为"需用户介入"
- 在ERROR_LOG.md中详细记录尝试过的方案

### Phase 3: 生成修复报告
在STEP_MANUAL.md的"已知问题"章节中写入：
```markdown
**自修复报告**：
- 发现错误总数: [X]
- 自动修复成功: [Y] (成功率 [Z]%)
- 遗留待确认: [N]个（详见上文"需用户介入"）
```

---

## 完整开发流程（必须严格执行）

### Step 0: 需求接收
- 用户提出需求
- **动作**：更新ITERATIVE_BOARD.md，填写原始需求，拆分步骤（3-7步）
- **输出**：展示步骤路线图，等待用户确认（或说"确认后开始步骤1"）

### Step 1: 开发阶段（编码+错误捕获）
- 编写代码
- **动作**：每完成一个函数/文件，使用`dev_test`验证
- **动作**：遇到任何错误，立即记录到ERROR_LOG.md（不准拖延）
- **动作**：继续开发其他部分（不要被错误阻断，先记录）

### Step 2: 自修复阶段（交付前强制）
- 完成步骤编码后
- **动作**：执行"自修复流程SOP"（Phase 1-3）
- **动作**：确保所有P0/P1错误已修复或标记为"需用户介入"
- **动作**：生成自修复报告

### Step 3: 交付阶段
- 自修复通过后
- **动作**：更新ITERATIVE_BOARD.md，标记当前步骤为"待测试"
- **动作**：编写/更新STEP_MANUAL.md（包含测试指南、已知问题、修复报告）
- **动作**：输出标准交付信息：
  ```text
  ✅ 步骤[X]开发完成
  
  📋 迭代看板：ITERATIVE_BOARD.md（查看整体进度）
  📄 错误记录：ERROR_LOG.md（查看开发过程遇到的问题）
  📖 交付手册：STEP_MANUAL.md（查看如何测试本步骤）
  
  ⛔ 我现在暂停，等待你测试。
  
  请按STEP_MANUAL.md第3节执行测试，在第5节填写反馈后告诉我。
  ```

### Step 4: 测试反馈处理
- 用户提供测试结果
- **动作**：更新ITERATIVE_BOARD.md，追加"迭代历史"（Round N）
- **动作**：如果测试失败，分析原因，返回Step 1（修复迭代）
- **动作**：如果测试通过，更新ITERATIVE_BOARD.md标记为"已完成"，开始Step 0（下一步骤）

---

## 禁止事项（红线）

1. **禁止**：开发过程中遇到错误不记录到ERROR_LOG.md（哪怕只是"小警告"）
2. **禁止**：未经过自修复就直接交付（必须修复P0/P1错误）
3. **禁止**：不更新STEP_MANUAL.md就告诉用户"测一下"
4. **禁止**：在ERROR_LOG.md中写"大概记得有个错"（必须包含完整traceback）
5. **禁止**：覆盖已修复的错误记录（保留历史，追加新记录）

---

## 立即执行检查

**请确认**:

1. ✅ **文件已创建**: `DOCS/ITERATIVE_BOARD.md`、`DOCS/ERROR_LOG.md`、`DOCS/STEP_MANUAL.md`、`DOCS/DEV_PROTOCOL.md`
2. ✅ **理解dev_test**: 确认理解错误捕获包装器的使用方式
3. ✅ **理解流程**: 确认理解完整开发流程（Step 0-4）

**状态汇报**: 三文件开发体系已建立，等待需求输入

---

**未来任何开发任务**，默认遵循此体系。如需简化（如极小的补丁），必须明确说"本次跳过错误捕获"，否则视为违规。
